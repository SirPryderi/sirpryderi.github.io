{"version":3,"file":"454-fa5d1d95dae3a4c2c247.js","mappings":"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","sources":["webpack://sirpryderi.github.io/./src/cosmos/cameraControls.ts","webpack://sirpryderi.github.io/./src/cosmos/scene.ts","webpack://sirpryderi.github.io/./src/cosmos/CosmosScene.tsx"],"sourcesContent":["import * as THREE from 'three'\n\n// Pre-allocated objects to avoid garbage collection\nconst _cameraBottomRightRay = new THREE.Vector3()\nconst _targetRayCamera = new THREE.Vector3()\nconst _targetRayWorld = new THREE.Vector3()\nconst _desiredDir = new THREE.Vector3()\nconst _targetQuaternion = new THREE.Quaternion()\nconst _targetLookDirection = new THREE.Vector3()\nconst _targetLookAt = new THREE.Vector3()\nconst _desiredQuaternion = new THREE.Quaternion()\nconst _tempMatrix = new THREE.Matrix4()\nconst _upVector = new THREE.Vector3(0, 1, 0)\nconst _cameraCenterRay = new THREE.Vector3(0, 0, -1)\nconst _cameraPosition = new THREE.Vector3()\n\n// Cache for frequently computed values\nlet _cachedFov = 0\nlet _cachedAspect = 0\nlet _cachedTanHalfFov = 0\nlet _cachedAspectTanHalfFov = 0\n\nexport function getCameraRotationQuat(\n  camera: THREE.PerspectiveCamera,\n  moon: THREE.Mesh,\n  scrollPercentage: number\n): THREE.Quaternion {\n  // Cache expensive trigonometric calculations\n  if (_cachedFov !== camera.fov || _cachedAspect !== camera.aspect) {\n    _cachedFov = camera.fov\n    _cachedAspect = camera.aspect\n    const fovRadians = camera.fov * (Math.PI / 180)\n    _cachedTanHalfFov = Math.tan(fovRadians / 2)\n    _cachedAspectTanHalfFov = _cachedAspect * _cachedTanHalfFov\n  }\n\n  // Reuse pre-allocated vector for bottom right direction\n  _cameraBottomRightRay.set(\n    _cachedAspectTanHalfFov,  // x: right offset\n    -_cachedTanHalfFov,       // y: down offset\n    -1                        // z: forward\n  ).normalize()\n\n  // Reuse pre-allocated vector for target ray interpolation\n  _targetRayCamera.copy(_cameraBottomRightRay).lerp(_cameraCenterRay, scrollPercentage).normalize()\n\n  // Get current target ray in world space using pre-allocated vector\n  _targetRayWorld.copy(_targetRayCamera).applyQuaternion(camera.quaternion)\n\n  // Find direction from camera to moon using pre-allocated vector\n  _desiredDir.subVectors(moon.position, camera.position).normalize()\n\n  // Calculate target look direction using pre-allocated objects\n  _targetQuaternion.setFromUnitVectors(_targetRayWorld, _desiredDir)\n\n  // Apply rotation to get target look direction\n  _targetLookDirection.set(0, 0, -1).applyQuaternion(camera.quaternion).applyQuaternion(_targetQuaternion)\n\n  // Get target look position\n  _targetLookAt.copy(camera.position).add(_targetLookDirection)\n\n  // Create desired quaternion using lookAt with pre-allocated objects\n  _tempMatrix.lookAt(camera.position, _targetLookAt, _upVector)\n  return _desiredQuaternion.setFromRotationMatrix(_tempMatrix)\n}\n\nexport function getOrbitalParameters(\n  mousePositionPercentage: THREE.Vector2,\n  scrollPercentage: number,\n  mouseOrbitRatio: number,\n  aspectRatio: number,\n): [number, number, number] {\n  let initialDistance = 80, finalDistance = 160\n  const initialRotation = 0, finalRotation = Math.PI * 1.2\n\n  if (aspectRatio < 1) {\n    // adjust orbit distance for vertical devices\n    initialDistance = THREE.MathUtils.lerp(160, 80, aspectRatio)\n    finalDistance = 360\n  }\n\n  // Target orbital parameters based on scroll\n  const targetDistance = THREE.MathUtils.lerp(initialDistance, finalDistance, scrollPercentage)\n  let targetHorizontalAngle = (mousePositionPercentage.x - 0.5) * Math.PI * 2 * -mouseOrbitRatio\n  let targetVerticalAngle = (mousePositionPercentage.y - 0.5) * Math.PI * mouseOrbitRatio\n  targetHorizontalAngle = targetHorizontalAngle - THREE.MathUtils.lerp(initialRotation, finalRotation, scrollPercentage)\n\n  return [targetDistance, targetHorizontalAngle, targetVerticalAngle]\n}\n\nexport function getCameraOrbitPosition(\n  mousePositionPercentage: THREE.Vector2,\n  scrollPercentage: number,\n  mouseOrbitRatio: number,\n  aspectRatio: number,\n): THREE.Vector3 {\n  const [distance, horizontalAngle, verticalAngle] = getOrbitalParameters(mousePositionPercentage, scrollPercentage, mouseOrbitRatio, aspectRatio)\n\n  return _cameraPosition.set(\n    Math.sin(horizontalAngle) * Math.cos(verticalAngle) * distance,\n    Math.sin(verticalAngle) * distance,\n    Math.cos(horizontalAngle) * Math.cos(verticalAngle) * distance,\n  )\n}\n\nexport function getCameraOrbitPositionSmooth(\n  camera: THREE.PerspectiveCamera,\n  mousePositionPercentage: THREE.Vector2,\n  scrollPercentage: number,\n  mouseOrbitRatio: number,\n  cameraPositionSpeed: number,\n): THREE.Vector3 {\n  const [targetDistance, targetHorizontalAngle, targetVerticalAngle] = getOrbitalParameters(mousePositionPercentage, scrollPercentage, mouseOrbitRatio, camera.aspect)\n\n  // Get current orbital parameters from camera position\n  const currentDistance = camera.position.length()\n  const currentHorizontalAngle = Math.atan2(camera.position.x, camera.position.z)\n  const currentVerticalAngle = Math.asin(camera.position.y / currentDistance)\n\n  // Handle angle wrapping for smooth interpolation\n  let angleDiff = targetHorizontalAngle - currentHorizontalAngle\n  if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI\n  if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI\n  const smoothTargetHorizontalAngle = currentHorizontalAngle + angleDiff\n\n  // Interpolate orbital parameters instead of position\n  const distance = THREE.MathUtils.lerp(currentDistance, targetDistance, cameraPositionSpeed)\n  const horizontalAngle = THREE.MathUtils.lerp(currentHorizontalAngle, smoothTargetHorizontalAngle, cameraPositionSpeed)\n  const verticalAngle = THREE.MathUtils.lerp(currentVerticalAngle, targetVerticalAngle, cameraPositionSpeed)\n\n  return _cameraPosition.set(\n    Math.sin(horizontalAngle) * Math.cos(verticalAngle) * distance,\n    Math.sin(verticalAngle) * distance,\n    Math.cos(horizontalAngle) * Math.cos(verticalAngle) * distance,\n  )\n}\n","import * as THREE from 'three'\nimport { getCameraOrbitPosition, getCameraOrbitPositionSmooth, getCameraRotationQuat } from './cameraControls'\n\nconst mouseOrbitRatio = 0.01\nconst cameraPositionSpeed = 0.02\nconst cameraRotationSpeed = 0.1\n\nlet [_viewportWidth, _viewportHeight] = getViewportSize()\n\nlet scrollPercentage = window.scrollY / (document.body.scrollHeight - _viewportHeight) || 0\nconst mousePositionPercentage = new THREE.Vector2(.5, .5)\n\nconst scene = new THREE.Scene()\nscene.background = new THREE.Color(0x0a0e0c)\n\n// Light\nconst light = new THREE.PointLight(0xffffff, 1)\nlight.position.set(-2000, 0, 0)\nscene.add(light)\n\n// Camera\nconst camera = new THREE.PerspectiveCamera(\n  35,\n  _viewportWidth / _viewportHeight,\n  0.1,\n  1000\n)\n\n// Renderer\nconst renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: \"high-performance\" })\nrenderer.setSize(_viewportWidth, _viewportHeight)\nrenderer.setClearColor(0x000000, 0)\n\nif (renderer.capabilities.isWebGL2) {\n  renderer.getContext().getExtension('EXT_texture_filter_anisotropic')\n}\n\nrenderer.setPixelRatio(window.devicePixelRatio)\n\n// Materials\nconst material = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 0, emissive: 0x0a0e0c })\n\nconst texture = new THREE.TextureLoader().load('/assets/texture.png')\ntexture.anisotropy = 8\ntexture.minFilter = THREE.LinearMipmapLinearFilter\ntexture.magFilter = THREE.LinearFilter\nmaterial.map = texture\n\nconst bumpTexture = new THREE.TextureLoader().load('/assets/displacement.jpg')\nbumpTexture.anisotropy = 8\nbumpTexture.minFilter = THREE.LinearMipmapLinearFilter\nbumpTexture.magFilter = THREE.LinearFilter\nmaterial.bumpMap = bumpTexture\nmaterial.bumpScale = 0.3\n\nmaterial.displacementMap = bumpTexture\nmaterial.displacementMap.wrapS = THREE.RepeatWrapping\nmaterial.displacementMap.wrapT = THREE.RepeatWrapping\nmaterial.displacementScale = 2\nmaterial.displacementBias = 1\n\n// Geometries\nconst geometry = createAdaptiveGeometry()\nconst mesh = new THREE.Mesh(geometry, material)\nscene.add(mesh)\n\ncamera.position.copy(getCameraOrbitPosition(mousePositionPercentage, scrollPercentage, mouseOrbitRatio, camera.aspect))\ncamera.quaternion.copy(getCameraRotationQuat(camera, mesh, scrollPercentage))\n\nfunction getViewportSize() {\n  const newWidth = window.visualViewport?.width || window.innerWidth\n  const newHeight = window.visualViewport?.height || window.innerHeight\n  return [newWidth, newHeight]\n}\n\nwindow.addEventListener('resize', onWindowResize, false)\nwindow.visualViewport?.addEventListener('resize', onWindowResize, false)\nfunction onWindowResize() {\n  const [newWidth, newHeight] = getViewportSize()\n  if (newWidth === _viewportWidth && newHeight === _viewportHeight) return\n  _viewportWidth = newWidth\n  _viewportHeight = newHeight\n  camera.aspect = _viewportWidth / _viewportHeight\n  renderer.setSize(_viewportWidth, _viewportHeight)\n  renderer.setPixelRatio(window.devicePixelRatio)\n  camera.updateProjectionMatrix()\n  render()\n}\n\nfunction createAdaptiveGeometry() {\n  const widthSegmentMax = 512, widthSegmentBase = 256, widthSegmentMin = 64\n  const heightSegmentMax = 256, heightSegmentBase = 128, heightSegmentMin = 32\n\n  const pixelRatio = window.devicePixelRatio || 1\n  const screenArea = _viewportWidth * _viewportHeight\n  const scaleFactor = Math.sqrt(screenArea / (1920 * 1080)) * pixelRatio\n\n  const widthSegments = Math.min(widthSegmentMax, Math.max(widthSegmentMin, Math.floor(widthSegmentBase * scaleFactor)))\n  const heightSegments = Math.min(heightSegmentMax, Math.max(heightSegmentMin, Math.floor(heightSegmentBase * scaleFactor)))\n\n  return new THREE.SphereGeometry(30, widthSegments, heightSegments)\n}\n\nfunction addStarsToSky() {\n  const starsGeometry = new THREE.BufferGeometry()\n  const starsMaterial = new THREE.PointsMaterial({ color: 0x888888 })\n\n  const stars = []\n  for (let i = 0; i < 1000; i++) {\n    const star = new THREE.Vector3()\n    star.x = THREE.MathUtils.randFloatSpread(2000)\n    star.y = THREE.MathUtils.randFloatSpread(2000)\n    star.z = THREE.MathUtils.randFloatSpread(2000)\n    stars.push(star)\n  }\n\n  starsGeometry.setFromPoints(stars)\n  const starField = new THREE.Points(starsGeometry, starsMaterial)\n  scene.add(starField)\n}\n\n// interactions\n\n\nwindow.addEventListener('mousemove', onMouseMove, false)\nfunction onMouseMove(event: MouseEvent) {\n  mousePositionPercentage.set(\n    event.clientX / _viewportWidth,\n    event.clientY / _viewportHeight\n  )\n\n  if (event.buttons !== 1) {\n    return\n  }\n}\n\nwindow.addEventListener('scroll', onScroll, false)\nfunction onScroll() {\n  scrollPercentage = window.scrollY / (document.body.scrollHeight - _viewportHeight) || 0\n}\n\naddStarsToSky()\n\nfunction render() {\n  renderer.render(scene, camera)\n}\n\nfunction setup() {\n  let animationHandle = 0\n\n  function animate() {\n    mesh.rotation.y = Date.now() / 500_000\n\n    camera.position.copy(getCameraOrbitPositionSmooth(camera, mousePositionPercentage, scrollPercentage, mouseOrbitRatio, cameraPositionSpeed))\n    camera.quaternion.slerp(getCameraRotationQuat(camera, mesh, scrollPercentage), cameraRotationSpeed)\n\n    render()\n    animationHandle = requestAnimationFrame(animate)\n  }\n\n  function stop() {\n    cancelAnimationFrame(animationHandle)\n  }\n\n  return { animate, stop, renderer }\n}\n\nexport { setup }","import React, { useRef, useEffect, memo } from \"react\"\nimport styled from \"styled-components\"\nimport { setup } from \"./scene\"\n\nconst CanvasContainer = styled.div`\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  z-index: -1;\n`\n\nfunction CosmosScene() {\n  const mountRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const { animate, stop, renderer } = setup()\n    mountRef.current!.replaceChildren(renderer.domElement)\n    animate()\n\n    return stop\n  }, [])\n\n  return <CanvasContainer ref={mountRef} />\n}\n\nconst CosmosSceneMemo = memo(CosmosScene)\n\nexport default CosmosSceneMemo\n"],"names":["_cameraBottomRightRay","THREE","_targetRayCamera","_targetRayWorld","_desiredDir","_targetQuaternion","_targetLookDirection","_targetLookAt","_desiredQuaternion","_tempMatrix","_upVector","_cameraCenterRay","_cameraPosition","_cachedFov","_cachedAspect","_cachedTanHalfFov","_cachedAspectTanHalfFov","getCameraRotationQuat","camera","moon","scrollPercentage","fov","aspect","fovRadians","Math","PI","tan","set","normalize","copy","lerp","applyQuaternion","quaternion","subVectors","position","setFromUnitVectors","add","lookAt","setFromRotationMatrix","getOrbitalParameters","mousePositionPercentage","mouseOrbitRatio","aspectRatio","initialDistance","finalDistance","finalRotation","targetDistance","targetHorizontalAngle","x","targetVerticalAngle","y","cameraPositionSpeed","cameraRotationSpeed","_viewportWidth","_viewportHeight","getViewportSize","window","scrollY","document","body","scrollHeight","scene","background","light","renderer","antialias","powerPreference","setSize","setClearColor","capabilities","isWebGL2","getContext","getExtension","setPixelRatio","devicePixelRatio","material","color","shininess","emissive","texture","load","anisotropy","minFilter","magFilter","map","bumpTexture","bumpMap","bumpScale","displacementMap","wrapS","wrapT","displacementScale","displacementBias","geometry","pixelRatio","screenArea","scaleFactor","sqrt","widthSegments","min","max","floor","heightSegments","createAdaptiveGeometry","mesh","visualViewport","_window$visualViewpor","width","innerWidth","_window$visualViewpor2","height","innerHeight","onWindowResize","newWidth","newHeight","updateProjectionMatrix","render","setup","animationHandle","animate","rotation","Date","now","currentDistance","length","currentHorizontalAngle","atan2","z","currentVerticalAngle","asin","angleDiff","smoothTargetHorizontalAngle","distance","horizontalAngle","verticalAngle","sin","cos","getCameraOrbitPositionSmooth","slerp","requestAnimationFrame","stop","cancelAnimationFrame","getCameraOrbitPosition","addEventListener","_window$visualViewpor3","event","clientX","clientY","buttons","starsGeometry","starsMaterial","stars","i","star","randFloatSpread","push","setFromPoints","starField","addStarsToSky","CanvasContainer","styled","div","CosmosScene","mountRef","useRef","useEffect","current","replaceChildren","domElement","React","ref","memo"],"sourceRoot":""}